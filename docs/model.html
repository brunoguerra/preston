<!DOCTYPE html>

<html>
<head>
  <title>model.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>model.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">'use strict'</span>;

<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);
<span class="hljs-keyword">var</span> async = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async'</span>);
<span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> queryHelper = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./query'</span>);
<span class="hljs-keyword">var</span> routes = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./routes'</span>);
<span class="hljs-keyword">var</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils'</span>);

<span class="hljs-built_in">module</span>.exports = Model;

<span class="hljs-comment">/**
 * Constructor.
 *
 * @see RestAPI#model
 *
 * @class
 * @param {RestAPI} restifier - The RestAPI instance
 * @param {mongoose.Model} model - The mongoose model that is being restified.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Model</span><span class="hljs-params">(restifier, model)</span> </span>{
  <span class="hljs-keyword">var</span> thiz = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">this</span>.restifier = restifier;
  <span class="hljs-keyword">this</span>.model = model;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Special fields</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> id;
  <span class="hljs-keyword">var</span> restricted = <span class="hljs-keyword">this</span>.restricted = [];
  model.schema.eachPath(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pathName, path)</span> </span>{
    <span class="hljs-keyword">if</span> (path.options.restricted) {
      restricted.push(pathName);
    }
    <span class="hljs-keyword">if</span> (path.options.id) {
      id = pathName;
    }
  });
  <span class="hljs-keyword">this</span>.id = id || <span class="hljs-string">'_id'</span>;

  <span class="hljs-keyword">this</span>.modifiers = [];
  <span class="hljs-keyword">this</span>.filters = {};
  <span class="hljs-keyword">this</span>.transformers = [];
  <span class="hljs-keyword">this</span>.submodels = {};
  <span class="hljs-keyword">this</span>.middlewares = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Remove restricted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.transform(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, doc)</span> </span>{
    _.forEach(restricted, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(path)</span> </span>{
      <span class="hljs-keyword">delete</span> doc[path];
    });
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Add id field</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.transform(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, doc)</span> </span>{
    doc.id = doc[thiz.id];
  });
}

<span class="hljs-comment">/**
 * Modifies a query parameter. Modifiers alter the query parameters that will
 * be passed to the pipeline. Modifiers are applied before any logic is called.
 * To modify a parameter, pass the name of the parameter you wish to modify and
 * a callback that returns the modified value of the parameter.
 *
 * @example
 * // A modifier that forces sorting by name ascending
 * model.modifyParam('sort', function(req, value) {
 *   value.name = 1;
 *   return value;
 * });
 *
 * @param {String} param - The param to modify. Can be limit, skip, populate, sort,
 *   any document field, or a parameter handled by a custom middleware.
 * @param {Function} modifier - The modifier(req, value[, cb]) function. Should return the new value.
 * @returns {Model} The instance of this model
 */</span>
Model.prototype.modifyParam = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(param, modifier)</span> </span>{
  <span class="hljs-keyword">this</span>.modifiers.push({
    param: param,
    fn: modifier
  });
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

<span class="hljs-comment">/**
 * Applies the modifiers of this model onto a request.
 *
 * @param {Request} request - The request
 */</span>
Model.prototype.applyModifiers = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request, done)</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyModifier</span><span class="hljs-params">(req, mod, next)</span> </span>{
    <span class="hljs-keyword">var</span> modFn = mod.fn;
    <span class="hljs-keyword">var</span> val = req.query[mod.param];</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Sync</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (modFn.length === <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> ret = modFn(req, val);
        <span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">delete</span> req.query[mod.param];
        } <span class="hljs-keyword">else</span> {
          req.query[mod.param] = ret;
        }
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">return</span> next(err, <span class="hljs-literal">null</span>);
      }
      <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, req);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Async</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    modFn(req, val, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, ret)</span> </span>{
      <span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">delete</span> req.query[mod.param];
      } <span class="hljs-keyword">else</span> {
        req.query[mod.param] = ret;
      }
      <span class="hljs-keyword">return</span> next(err, req);
    });
  }

  async.reduce(<span class="hljs-keyword">this</span>.modifiers, request, applyModifier, done);
};
<span class="hljs-comment">/**
 * Modifies the limit parameter. Internally, this applies a {@link modifyParam} that restricts
 * the limit parameter to be no greater than what is given here.
 *
 * @example
 * model.limit(5); // Now only 5 documents can be returned max
 *
 * // GET /model?limit=4 - Returns 4 documents
 * // GET /model?limit=5 - Returns 5 documents
 * // GET /model?limit=6 - Returns 5 documents
 *
 * @param {Number} num - The maximum number of documents that can be returned.
 * @returns {Model} The instance of this model
 */</span>
Model.prototype.limit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(num)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.modifyParam(<span class="hljs-string">'limit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, value)</span> </span>{
    <span class="hljs-keyword">return</span> (value &amp;&amp; !<span class="hljs-built_in">isNaN</span>(value)) ? <span class="hljs-built_in">Math</span>.min(num, value) : num;
  });
};

<span class="hljs-comment">/**
 * Adds a filter to this model. Filters are user-defined functions that modify the
 * query. They work very similarly to AngularJS filters. They can be chained and
 * take parameters, allowing immense flexibility for developers to add features to APIs.
 *
 * Filters are called like this:
 * ```
 * GET /people?filter=children
 * ```
 *
 * They can also be chained like this:
 * ```
 * GET /people?filter=children | proximity 5
 * ```
 *
 * @example
 * // A simple filter
 * model.filter('children', function(req, query) {
 *   query.where('age').lt(18);
 * });
 *
 * // A filter that takes parameters:
 * model.filter('proximity', function(req, query, distance) {
 *   query.where('location').maxDistance(distance);
 * });
 *
 * @param {String} name - The name of the filter (case sensitive).
 * @param {Function} filter - The filter function (req, query, params...) that will be applied to queries.
 */</span>
Model.prototype.filter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, filter)</span> </span>{
  <span class="hljs-keyword">this</span>.filters[name] = filter;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

<span class="hljs-comment">/**
 * Adds a transformer to this model. Transformers change the returned results.
 * One transformer is built in, the restricted transformer, and cannot be changed.
 *
 * @example
 * model.transform(function(req, doc) {
 *   delete doc._id;
 *   delete doc.password;
 *   doc.type = 'This is a string that isn\'t in the database!';
 * });
 *
 * @param {Function} transformer - The transformer(req, doc[, next]).
 * @returns {Model} The instance of this model
 */</span>
Model.prototype.transform = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(transformer)</span> </span>{
  <span class="hljs-keyword">this</span>.transformers.push(transformer);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

<span class="hljs-comment">/**
 * Adds a population transformer to this model. Population transformers are
 * transformers that operate on populated fields. They can be used to make
 * your application more secure by removing fields you don't want people to see.
 *
 * @example
 * model.transformPopulate('owners', function(req, doc) {
 *   delete doc._id;
 *   delete doc.password;
 * });
 *
 * @param {String} field - The populated field to transform.
 * @param {Function} transformer - The transform function(req, doc[, next])
 * @returns {Model} The instance of this model
 */</span>
Model.prototype.transformPopulate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(field, transformer)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Wrapper so we have the correct number of args</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callTransform</span><span class="hljs-params">(req, doc, next)</span> </span>{
    <span class="hljs-keyword">var</span> pop = doc[field];
    <span class="hljs-keyword">if</span> (!pop) {
      <span class="hljs-keyword">return</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Normalize</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> single = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pop === <span class="hljs-string">'object'</span> &amp;&amp; !<span class="hljs-built_in">Array</span>.isArray(pop)) {
      pop = [pop];
      single = <span class="hljs-literal">true</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Ensure array, as it isn’t an object at this point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(pop)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>fail silently. This may change in the future</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (next) {
        <span class="hljs-keyword">return</span> next();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>;
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Loop through
Sync</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (transformer.length === <span class="hljs-number">2</span>) {
      _.forEach(pop, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(subDoc)</span> </span>{
        transformer(req, subDoc);
      });
      <span class="hljs-keyword">return</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Async</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    async.map(pop, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(subDoc, done)</span> </span>{
      transformer(req, subDoc, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
        <span class="hljs-keyword">return</span> done(err, subDoc);
      });
    }, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span> </span>{
      <span class="hljs-keyword">if</span> (single) {
        result = result[<span class="hljs-number">0</span>];
      }
      doc[field] = result;
      next();
    });
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Synchronous</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (transformer.length === <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.transform(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, doc)</span> </span>{
      callTransform(req, doc);
    });
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Async</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.transform(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, doc, next)</span> </span>{
    callTransform(req, doc, next);
  });
};

<span class="hljs-comment">/**
 * Applies all of the transforms defined on this model on a document.
 *
 * @param {Request} req - The request.
 * @param {Document} doc - The document to apply the transforms to.
 * @param {Function} [cb] - The cb(err, result) where result is the transformed document.
 * @returns {Object} The transformed document as a JavaScript object.
 */</span>
Model.prototype.applyTransforms = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, doc, cb)</span> </span>{
  async.reduce(<span class="hljs-keyword">this</span>.transformers, doc.toObject(), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(memo, tf, next)</span> </span>{
    <span class="hljs-keyword">if</span> (tf.length === <span class="hljs-number">2</span>) {
      tf(req, memo);
      next(<span class="hljs-literal">null</span>, memo);
    } <span class="hljs-keyword">else</span> {
      tf(req, memo, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
        <span class="hljs-keyword">return</span> next(err, memo);
      });
    }
  }, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span> </span>{
    cb(err, result);
  });
};

<span class="hljs-comment">/**
 * Uses a middleware on a certain route. These middlewares are called in the order that they are added
 * to this model.
 *
 * @param {String} route - The route. Can be one of all, query, create, get, update, destroy.
 * @param {Function} middleware - The middleware(req, res, next).
 * @returns {Model} The instance of this model
 */</span>
Model.prototype.use = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(route, middleware)</span> </span>{
  route = route.toLowerCase();
  <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">this</span>.middlewares[route] || (<span class="hljs-keyword">this</span>.middlewares[route] = []);
  arr.push(middleware);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

<span class="hljs-comment">/**
 * Makes a field a submodel, meaning that field
 * has its own routes for query/crud.
 *
 * Note that you cannot create a submodel of a submodel.
 *
 * @param field - The field to submodel
 * @param correspondsTo - The submodel's field that corresponds to this model.
 * @param model - The mongoose model
 * @returns {Model} A model which is prefixed with this model's route.
 */</span>
Model.prototype.submodel = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(field, correspondsTo, model)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Check if valid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Submodels of submodels not allowed for model "'</span> + <span class="hljs-keyword">this</span>.model.modelName + <span class="hljs-string">'".'</span>);
  }

  <span class="hljs-keyword">var</span> submodel = <span class="hljs-keyword">this</span>.submodels[field] = <span class="hljs-keyword">new</span> Model(<span class="hljs-keyword">this</span>.restifier, model);
  submodel.parent = <span class="hljs-keyword">this</span>;
  submodel.parentField = field;
  submodel.parentCorrespondsTo = correspondsTo;
  <span class="hljs-keyword">return</span> submodel;
};

<span class="hljs-comment">/**
 * Serves this model on a RESTful API.
 * Don't use this method; use the middleware instead via {@link RestAPI#middleware}.
 *
 * @param {express.Router} router - The Express router to serve the model on.
 * @returns {Model} The instance of this model
 */</span>
Model.prototype.serve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(router)</span> </span>{
  <span class="hljs-keyword">var</span> thiz = <span class="hljs-keyword">this</span>;

  <span class="hljs-keyword">var</span> uriBase = <span class="hljs-string">'/'</span> + (<span class="hljs-keyword">this</span>.parent || <span class="hljs-keyword">this</span>).model.collection.name;
  <span class="hljs-keyword">var</span> uriDoc = uriBase + <span class="hljs-string">'/:id'</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent) {
    uriBase = uriDoc + <span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.parentField;
    uriDoc = uriBase + <span class="hljs-string">'/:sid'</span>;
  }

  <span class="hljs-keyword">var</span> middleware = [queryHelper.queryParser, queryHelper.docFetcher(<span class="hljs-keyword">this</span>)];
  middleware = middleware.concat(<span class="hljs-keyword">this</span>.middlewares.all || []); <span class="hljs-comment">// 'all' middleware</span>
  <span class="hljs-keyword">var</span> routeMiddleware = {};
  [<span class="hljs-string">'query'</span>, <span class="hljs-string">'create'</span>, <span class="hljs-string">'get'</span>, <span class="hljs-string">'update'</span>, <span class="hljs-string">'destroy'</span>].filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(route)</span> </span>{
    routeMiddleware[route] = middleware.slice()
      .concat(thiz.middlewares[route] || []);
  });

  router.route(uriBase)
    .get(routeMiddleware.query, routes.query(<span class="hljs-keyword">this</span>))
    .post(routeMiddleware.create, routes.create(<span class="hljs-keyword">this</span>))
    .all(routes.default);

  router.route(uriDoc)
    .get(routeMiddleware.get, routes.get(<span class="hljs-keyword">this</span>))
    .put(routeMiddleware.update, routes.update(<span class="hljs-keyword">this</span>))
    .patch(routeMiddleware.update, routes.update(<span class="hljs-keyword">this</span>))
    .delete(routeMiddleware.destroy, routes.destroy(<span class="hljs-keyword">this</span>))
    .all(routes.default);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

<span class="hljs-comment">/**
 * Creates a middleware of this model. It is preferable to use {@link RestAPI#middleware}
 * as that function provides the necessary error handling and invalid method middlewares.
 *
 * @returns {Middleware} The middleware corresponding to this model.
 */</span>
Model.prototype.middleware = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> router = express.Router();
  <span class="hljs-keyword">this</span>.serve(router);
  <span class="hljs-keyword">return</span> router;
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
